#String part 1

#A.donuts
#Given an int count of number of donuts, return a string of the form 'Number of donuts: <count>', where <count> is the number passed in.
#However if the count is 10 or more, then use the word 'many' instead of the actual count.
#So donuts(5) returns 'Number of donuts: 5' and donuts(23) returns  'Number of donuts: many'
def donuts(count):
  if count>=10
    print 'Number of donuts: '
    print 'many'
  else
    print 'Number of donuts: '
    print count
  return

#B.both_ends
#Given a string s, return a string made of the first 2 and the last 2 chars of the original string, so 'spring' yields 'spng'.
#However, if the string length is less, than 2, return instead the empty string.
def both_ends(s):
  if len(s)<2:
    print ' '
  else
    print s[0:1]
    print s[-2:-1]
  return

#C.fix_start
#Given a string s, return a string where all occurences of its first char have been changed to '*', except do not change the first char itself.
#e.g. 'babble' yields 'ba**le'
#Assume that the string is length 1 or more.
#Hint: s.replace (stra, strb) returns a version of string s where all instances of stra have been replaced by strb.
def fix_start(s):
  stra=s[0]
  strb=s[1:]
  for item in strb:
    if strb[item]==stra: #*
      strb[item]='*'
    print item
  return
#* if strb[item]==stra: s.replace(item, "*", len(strb)) ???

#D.MixUp
#Given strings a and b, return a single sttring with a and b separated by a space '<a> <b>', except swap the first 2 chars of each string.
#e.g. 'mix', 'pod' -> 'pox mid', 'dog', 'dinner' -> 'dig donner'
#Assume a and b are length 2 or more.
def mix_up(a,b):
  strb=a[0:1]+b[2:]
  stra=b[0:1]+a[2:]
  print stra+' '+strb
  return
  
#Provided simple test() function used in main() to print what each function returns vs. what it's supposed to return
def test(got, expected):
  if got==expected:
    prefix='OK'
  else:
    prefix='X'
  print ('%s got: %s expected: %s' % (prefix, repr(got), repr(expected)))
  
#Provided main() calls the above functions with interesting inputs, using test() to check if each result is correct or not.

def main():
  print ('donuts')
  #Each line calls donuts, compares its result to the expected for the call
  test(donuts(4), 'Number of donuts: 4')
  test(donuts(9), 'Number of donuts: 9')
  test(donuts(10), 'Number of donuts: many')
  test(donuts(99), 'Number of donuts: many')
  
  print()
  print('both_ends')
  test(both_ends('spring'), 'spng')
  test(both_ends('Hello'), 'Helo')
  test(both_ends('a'), 'a')
  test(both_ends('xyz'), 'xyyz')
  
  print()
  print('fix_start')
  test(fix_start('babble'), 'ba**le')
  test(fix_start('aardvark'), 'a*rdv*rk')
  test(fix_start('google'), 'goo*le')
  test(fix_start('donut'), 'donut')
  
  print()
  print('mix_up')
  test(mix_up('mix', 'pod'), 'pox mid')
  test(mix_up('dog', 'dinner'), 'dig donner')
  test(mix_up('gnash', 'sport'), 'spash gnort')
  test(mix_up('pezzy', 'firm'), 'fizzy perm')
  
#Standard boilerplate to call the main() function
if _name_='_main_':
  main()

#String part2

#D.verbing
#Given a string, if its length is at least 3, add 'ing', to its end.
#Unless it already ends in 'ing', in which care add 'ly' instead.
#If the string length is less than 3, leave it unchanged.
#Return the resulting string.
def verbing(s):
  if len(s)<3:
    print s
  else if s[-3:-1]=='ing':
    print s+'ly'
  else:
    print s+'ing'
  return
  
 #E.not_bad (???)
 #Given a string, find the first appearance of the substring 'not' and 'bad'.
 #If the 'bad' follows the 'not', replace the whole 'not'...'bad' substring with 'good'.
 #Return the resulting string.
 #So 'This dinner is not that bad!' yields: This dinner is good!
 def not_bad(s):
  #your code is here
  return

#F.front_back
#Consider dividing a string into two halves.
#If the length is even, the front and back halves are the same length.
#If the length is odd, we'll say that the extra char goes in the front half.
#e.g. 'abcde', the front half is 'abc', the back half is 'de'
#Given 2 strings, a and b, return a string of the form:
#a_front+b_front+a_back+b_back
def front_back(a,b):
  a_hosszf = len(a)/2
  b_hosszf = len(b)/2
  if len(a) % 2 == 1:
    a_hosszf = a_hosszf + 1
  if len(b) % 2 == 1:
    b_hosszf = b_hosszf + 1
  a_front = a[:a_hosszf]
  b_front = b[:b_hosszf]
  a_back = a[a_hosszf:]
  b_back = b[b_hosszf:]
  print a_front+b_front+a_back+b_back
  return
  return
  return

#Simple provided test() function used in main() to print what each function returns vs. what it's supposed to return.
def test(got, excepted):
  if got==expected:
    prefix='OK'
  else:
    prefix='X'
  print ('%s got: %s expected: %s' % (prefix, repr(got), repr(expected)))
  
 #main() calls the above functions with interesting inputs, using the above test() to check if the result is correct or not
 
 def main():
  print ('verbing')
  test(verbing('hail'), 'hailing')
  test(verbing('swimming'),'swmmingly')
  test(verbing('do'), 'do')
  
  print('\nnot_bad')
  test(not_bad('This movie is not so bad'), 'This movie is good')
  test(not_bad('This tea is not hot'), 'This tea is not hot')
  test(not_bad("It's bad yet hot"), "It's bad yet hot")
  
  print('\nfront_back')
  test(front_back('abcd', 'xy'), 'abcxcdy')
  test(front_back('abcde', 'xyz'), 'abcxydez')
  test(front_back('Kitten', 'Donut'), 'KitDontenut')
  
  if _name_='_main_':
    main()
    
  #List part 1
  #List part 2
